/*
 * Wazuh Vulnerability scanner - Database Feed Manager
 * Copyright (C) 2015, Wazuh Inc.
 * December 06, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _VERSION_OBJECT_DPKG_HPP
#define _VERSION_OBJECT_DPKG_HPP

#include "iVersionObjectInterface.hpp"
#include "stringHelper.h"
#include "vulnerabilityScannerDefs.hpp"
#include <cctype>
#include <charconv>
#include <cstring>
#include <iostream>
#include <limits.h>
#include <memory>
#include <regex>
#include <string>
#include <string_view>

/**
 * @brief Dpkg data struct.
 *
 */
struct Dpkg
{
    uint32_t epoch;       ///< Epoch.
    std::string version;  ///< Version.
    std::string revision; ///< Revision.
};

/**
 * @brief VersionObjectDpkg class.
 *
 */
class VersionObjectDpkg final : public IVersionObject
{
private:
    long m_epoch;
    std::string m_version;
    std::string m_revision;

    /**
     * Check if character is blank (space or tab only, like c_isblank)
     */
    bool isBlank(char c) const
    {
        return c == ' ' || c == '\t';
    }

    /**
     * Give a weight to the character to order in the version comparison.
     *
     * @param chr An ASCII character.
     */
    int order(char chr) const
    {
        if (std::isdigit(chr))
        {
            return 0;
        }
        else if (std::isalpha(chr))
        {
            return chr;
        }
        else if (chr == '~')
        {
            return -1;
        }
        else if (chr)
        {
            return chr + 256;
        }
        else
        {
            return 0;
        }
    }

    /**
     * Make the version comparison with the upstream version and the debian revision.
     *
     * @param leftSide An array of characters.
     * @param rightSide An array of characters.
     */
    int compareVersionAndRevision(const char* leftSide, const char* rightSide) const
    {
        if (leftSide == nullptr)
        {
            leftSide = "";
        }
        if (rightSide == nullptr)
        {
            rightSide = "";
        }

        while (*leftSide || *rightSide)
        {
            int firstDiff = 0;

            while ((*leftSide && !std::isdigit(*leftSide)) || (*rightSide && !std::isdigit(*rightSide)))
            {
                int firstAux = order(*leftSide);
                int secondAux = order(*rightSide);

                if (firstAux != secondAux)
                    return firstAux - secondAux;

                leftSide++;
                rightSide++;
            }
            while (*leftSide == '0') leftSide++;
            while (*rightSide == '0') rightSide++;
            while (std::isdigit(*leftSide) && std::isdigit(*rightSide))
            {
                if (!firstDiff)
                    firstDiff = *leftSide - *rightSide;
                leftSide++;
                rightSide++;
            }

            if (std::isdigit(*leftSide))
                return 1;
            if (std::isdigit(*rightSide))
                return -1;
            if (firstDiff)
                return firstDiff;
        }

        return 0;
    }

    /**
     * Compares two Debian versions.
     *
     * This function follows the convention of the comparator functions used by
     * qsort().
     *
     * @see deb-version(5)
     *
     * @param rEpoch The second epoch.
     * @param rVersion The second version.
     * @param rRevision The second revision.
     *
     * @retval 0 If a and b are equal.
     * @retval <0 If a is smaller than b.
     * @retval >0 If a is greater than b.
     */
    int compareDpkgVersion(const long rEpoch, const std::string& rVersion, const std::string& rRevision) const
    {
        if (m_epoch > rEpoch)
            return 1;
        if (m_epoch < rEpoch)
            return -1;

        auto result = compareVersionAndRevision(m_version.c_str(), rVersion.c_str());
        if (result)
            return result;

        return compareVersionAndRevision(m_revision.c_str(), rRevision.c_str());
    }

public:
    /**
     * @brief Static method to match a version string to a Dpkg object.
     *
     * @param version version string to match.
     * @param output Dpkg object to store the result.
     * @return true/false according to match condition.
     */
    static bool match(const std::string& input, Dpkg& out)
    {
        // Use string_view for efficient string operations (available in C++17)
        const std::string_view ASCII_WS = " \t\r\n\f\v";

        auto trim_ascii = [&](std::string_view sv) -> std::string_view
        {
            const auto left = sv.find_first_not_of(ASCII_WS);
            if (left == std::string_view::npos)
            {
                return std::string_view();
            }
            const auto right = sv.find_last_not_of(ASCII_WS);
            return sv.substr(left, right - left + 1);
        };

        auto has_embedded_ws = [&](std::string_view sv) -> bool
        {
            return sv.find_first_of(ASCII_WS) != std::string_view::npos;
        };

        auto parse_epoch = [&](std::string_view sv, long& epoch, std::string_view& rest) -> bool
        {
            const auto colon_pos = sv.find(':');
            if (colon_pos == std::string_view::npos)
            {
                epoch = 0;
                rest = sv;
                return true;
            }

            // Require digits before colon and content after it
            if (colon_pos == 0 || colon_pos + 1 >= sv.size())
            {
                return false;
            }

            const std::string_view epoch_str = sv.substr(0, colon_pos);

            // Convert to string for strtoll (GCC 9.4 compatibility)
            const std::string epoch_string(epoch_str);
            char* end_ptr = nullptr;
            errno = 0;
            long long parsed = std::strtoll(epoch_string.c_str(), &end_ptr, 10);

            if (end_ptr != epoch_string.c_str() + epoch_string.size() || errno == ERANGE)
            {
                return false;
            }
            if (parsed < 0 || parsed > INT_MAX)
            {
                return false;
            }

            epoch = static_cast<long>(parsed);
            rest = sv.substr(colon_pos + 1);

            // No more colons after epoch separator
            return rest.find(':') == std::string_view::npos;
        };

        auto is_alnum_ascii = [](unsigned char c) -> bool
        {
            return std::isalpha(c) || std::isdigit(c);
        };

        auto is_valid_upstream = [&](std::string_view v) -> bool
        {
            if (v.empty())
            {
                return false;
            }
            // Keep stricter "must start with digit" behavior:
            if (!std::isdigit(static_cast<unsigned char>(v.front())))
            {
                return false;
            }
            for (unsigned char c : v)
            {
                const bool ok = is_alnum_ascii(c) || c == '.' || c == '+' || c == '~' || c == '-';
                if (!ok)
                {
                    return false; // Note: ':' is not allowed here.
                }
            }
            return true;
        };

        auto is_valid_revision = [&](std::string_view v) -> bool
        {
            for (unsigned char c : v)
            {
                const bool ok = is_alnum_ascii(c) || c == '.' || c == '+' || c == '~';
                if (!ok)
                {
                    return false; // Note: ':' is not allowed here.
                }
            }
            return true;
        };

        auto split_upstream_revision =
            [&](std::string_view sv, std::string_view& upstream, std::string_view& revision) -> bool
        {
            const auto dash = sv.rfind('-'); // last hyphen is the separator
            if (dash == std::string_view::npos)
            {
                upstream = sv;
                revision = std::string_view(); // Explicit constructor for GCC 9.4
                return true;
            }
            if (dash + 1 >= sv.size())
            {
                return false; // empty revision
            }
            upstream = sv.substr(0, dash);
            revision = sv.substr(dash + 1);
            return true;
        };

        // Normalize input
        std::string_view s = trim_ascii(input);
        if (s.empty())
        {
            return false;
        }
        if (has_embedded_ws(s))
        {
            return false;
        }

        // Parse epoch and remainder
        long epoch = 0;
        std::string_view remainder;
        if (!parse_epoch(s, epoch, remainder))
        {
            return false;
        }

        // Split upstream/revision at LAST '-'
        std::string_view upstream, revision;
        if (!split_upstream_revision(remainder, upstream, revision))
        {
            return false;
        }

        // Validate upstream/revision
        if (!is_valid_upstream(upstream))
        {
            return false;
        }
        if (!revision.empty() && !is_valid_revision(revision))
        {
            return false;
        }

        // Assign the output to fill structs (only convert to string at the end)
        out.epoch = static_cast<uint32_t>(epoch);
        out.version = std::string(upstream);
        out.revision = std::string(revision);

        return true;
    }

    /**
     * @brief Constructor.
     *
     * @param version version SemVer object.
     */
    explicit VersionObjectDpkg(const Dpkg& version)
        : m_epoch {version.epoch}
        , m_version {version.version}
        , m_revision {version.revision}
    {
    }

    // LCOV_EXCL_START
    ~VersionObjectDpkg() override = default;
    // LCOV_EXCL_STOP

    /**
     * @brief Returns the VersionObjectType of this class.
     *
     * @return VersionObjectType.
     */
    VersionObjectType getType() override
    {
        return VersionObjectType::DPKG;
    }

    /**
     * @brief Comparison operator ==.
     *
     * @param b comparison rhs object.
     * @return true/false according to equality condition.
     */
    bool operator==(const IVersionObject& b) const override
    {
        const auto* pB = dynamic_cast<const VersionObjectDpkg*>(&b);
        if (pB == nullptr)
        {
            throw std::runtime_error {"Error casting VersionObject type"};
        }
        return compareDpkgVersion(pB->m_epoch, pB->m_version, pB->m_revision) == 0;
    }

    /**
     * @brief Comparison operator <.
     *
     * @param b comparison rhs object.
     * @return true/false according to less than condition.
     */
    bool operator<(const IVersionObject& b) const override
    {
        const auto* pB = dynamic_cast<const VersionObjectDpkg*>(&b);
        if (pB == nullptr)
        {
            throw std::runtime_error {"Error casting VersionObject type"};
        }
        return compareDpkgVersion(pB->m_epoch, pB->m_version, pB->m_revision) < 0;
    }
};

#endif // _VERSION_OBJECT_DPKG_HPP
